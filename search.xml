<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>失败</title>
    <url>/2024/05/09/%E5%A4%B1%E8%B4%A5/</url>
    <content><![CDATA[<p>你知道的，世界是五颜六色的，这绘出了无数人的一生，自然也包括了我的。如果说别人是姹紫嫣红的缤纷人生，那么我的人生就是由灰色碎片构成的。</p>
<p>或许在旁人眼中，我是一个无聊的人，平时话也不说几句，走路上也摆着一张臭脸，让人毫无交往的欲望，反正我自己是这样想的。</p>
<p>我本以为自己喜欢安静，但真正安静下来后，我才知道，安静真是一坨屎，我只是在逃避我无法融入的环境，逃避着一切陌生事物，我不喜欢安静，也不喜欢这样的自己，我想回家。</p>
<p>从小学到大学，我感觉自始至终我都是最不合群的那个，我找不到真正的自我。</p>
<p>我曾在操场上和同学飞奔，嬉戏玩闹，也曾跟三五个同学放学去电玩店打拳皇或者是任天堂的一些多人游戏，甚至跟同桌一起翘晚自习去校园角落喂猫，这些片段为我的生活增添一瞬的色彩，也仅仅如此，这些东西并不是我真正想要追求的，正如此所谓的色彩不久后便被麻木的生活吞噬掉。</p>
<p>高三上册，我因为生病需要做手术，那段时间正好是期中考试，下午考完试后，大家吃饭的吃饭，洗澡的洗澡，每个人都从考试状态回到日常当中，只有我，走向了校门外。我一个人在车站等了好久的公交车，终于等来了一辆。因为是起点站，只有我在车上，后面人也逐渐多了，但车厢仍然宽敞。已经是秋天了，红色的晚霞逐渐淡去，阴影开始笼罩世界，路边的太阳能灯也一排排亮起，异样的情绪在我的心中滋生。</p>
<p>车上坐着的人，大多是结束了一天工作的上班族，我从未在这个时间坐过公交车，也只在小说中看到过这种情节，每个人好像独自处在自己的世界中，对车上其他陌生人没有丝毫关注。有个女白领正在跟丈夫打电话，跟他抱怨着上班的烦恼，但时不时会露出由心的笑容；有几个初中生正玩着农药，还在外放；还有一些大叔大妈在车厢前面聊着杂七杂八的家常，有人到站了后大家还会向他告别然后接着聊……</p>
<p>每个人好像都幸福地生活在自己的世界中，我似乎和车上的所有人都不同，他们的世界是我无法接触的，此时天色完全暗了下来，公交车已经驶入我家所在的老城区，尽管叫老城区，这里仍然很热闹。</p>
<p>只是这些热闹与我完全无关，我是一名高中生，每天重复着早上六点起来，学习到晚上十点半然后十一点熄灯睡觉的机械生活。</p>
<p>绝望的窒息感袭来，我与大家的世界似乎隔了一层透明的墙壁，外面张灯结彩，大家都洋溢着一天的劳动结束了的欢乐笑容，开始了自己的生活，而我只是一个过客，我就像是一头被关在阴暗监狱的恶心怪物，贪婪地窥探着人们的生活，但又无法冲破这该死的牢笼，窒息感加重，那一刻我明白了：我连成为普通人的权利都没有。</p>
<p>绝望把我的思绪拉长，我想到了未来，我想着是否会有人在我结束了一天的工作后，在家等我回家，会为我排解一天的难受情绪，我们之间还会有温馨的日常生活，想着想着，我想哭了，因为这些都是想象，我却看到真正这样的生活发生在行人身上，眼前所见，万家灯火通明，却无一灯为我而明。</p>
<p>经过一处树荫，阴影吞噬了整个车厢，在极致的黑暗中，我想明白了，我真正追求的是一个跟我同类的灵魂，我讨厌孤独，我害怕孤独，在这一眼望不到头的世界，我想要一个能够理解我的灵魂。</p>
<p>下车后，还有一段一千米的大道，直通我家小区门口。都说南方人十二点才刚刚开始夜生活，现在七点，但道路两旁的房子都没几户亮着灯，昏黄的路灯，寂静的街道，无法改变自己生活的绝望让泪水在我眼里打转，我强忍着走到了小区门口，本以为就这么过去了，没想到一件件往事带来的负面情绪犹如洪水般冲击着我的情绪防线，这是回家的尽头，也是我另一个绝望生活的开始吗？</p>
<p>我终于忍不住了，大颗滚烫的泪水掉到了地上，我受不了了。</p>
]]></content>
      <tags>
        <tag>失败</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA字符串</title>
    <url>/2024/05/22/JAVA%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h1 id="字符串基本知识"><a href="#字符串基本知识" class="headerlink" title="字符串基本知识"></a>字符串基本知识</h1><h2 id="创建字符串"><a href="#创建字符串" class="headerlink" title="创建字符串"></a>创建字符串</h2><p>你知道的，常见创建字符串手段有：<br>\1. 每当有一个<strong>字面值</strong>出现的时候，虚拟机就会创建一个字符串<br>\2. 调用String的构造方法创建一个字符串对象<br>\3. 通过+加号进行字符串拼接也会创建新的字符串对象</p>
<p>就像下面喵：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        String ewoji=<span class="string">&quot;你鸡&quot;</span>;<span class="comment">//&quot;你鸡&quot;就是字面值喵</span></span><br><span class="line">        String str=<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;我鸡&quot;</span>);<span class="comment">//通过构造函数new一个对象喵</span></span><br><span class="line">        <span class="type">char</span>[] cs=<span class="keyword">new</span> <span class="title class_">char</span>[]&#123;<span class="string">&#x27;想&#x27;</span>,<span class="string">&#x27;岁&#x27;</span>,<span class="string">&#x27;交&#x27;</span>&#125;;</span><br><span class="line">        String c=<span class="keyword">new</span> <span class="title class_">String</span>(cs);<span class="comment">//字符数组可以通过String构造函数变成String类喵</span></span><br><span class="line">        String strewoji=str+ewoji;<span class="comment">//字符串之间可以通过+号拼接喵，结果是&quot;我鸡你鸡&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="字符串特性"><a href="#字符串特性" class="headerlink" title="字符串特性"></a>字符串特性</h2><h3 id="final-不可继承"><a href="#final-不可继承" class="headerlink" title="final(不可继承)"></a>final(不可继承)</h3><p><img src="javaString%E7%B1%BB%E6%BA%90%E7%A0%81.png" alt="javaString类源码"></p>
<p>我是黑客喵，在IDEA中运用了ctrl+鼠标左键可以查看源码，这里我通过高超的黑客技术成功看到了String类的源码，可以看到它被final修饰，也就是说他不能被继承，但是如果你硬要继承的话，可以迎接一个名为报错的结果。<img src="%E7%BB%A7%E6%89%BFString%E7%B1%BB%E6%8A%A5%E9%94%99.png" alt="继承String类报错"></p>
<h3 id="immutable-不可变"><a href="#immutable-不可变" class="headerlink" title="immutable(不可变)"></a>immutable(不可变)</h3><p><strong>不可变</strong>的具体含义是指：<br>不能增加长度<br>不能减少长度<br>不能插入字符<br>不能删除字符<br>不能修改字符<br>一旦创建好这个字符串，里面的内容 <strong>永远</strong> 不能改变</p>
<p>这时候有人就会说了，Chaospeo老师，Chaospeo老师，你这话不是放屁吗，我这样不就是修改字符串了吗</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">            String s=<span class="string">&quot;未修改&quot;</span>;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">            s=<span class="string">&quot;修改了&quot;</span>;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你看他们输出内容都不同，这不是换了是什么？<img src="%E4%BF%AE%E6%94%B9%EF%BC%9F.png" alt="修改？"></p>
<p>那我们再写一个代码，这次我们加一个String类型的变量b，b和s同样引用”未修改”</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">            String s=<span class="string">&quot;未修改&quot;</span>;</span><br><span class="line">        	String b=s;</span><br><span class="line">            System.out.println(b);</span><br><span class="line">            s=<span class="string">&quot;修改了&quot;</span>;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        	System.out.println(<span class="string">&quot;s和b引用的是同一个玩意吗:&quot;</span>+(s==b));<span class="comment">//==可以判断引用对象是否相同</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为<img src="%E4%BF%AE%E6%94%B9%EF%BC%81.png" alt="修改！"></p>
<p>可以看到，最初的s和b确实是引用”未修改”，但是通过&#x3D;&#x3D;判断可以得知，修改后的s和b引用的并不是同一个对象，s已经变成另一个字符串了，不再是最初的它了，所以上面说的修改完全就是诡辩，这完全是新的字符串而不是在原有的字符串进行修改。</p>
]]></content>
      <tags>
        <tag>入门</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>灵光一闪--对顶栈</title>
    <url>/2024/03/08/%E7%81%B5%E5%85%89%E4%B8%80%E9%97%AA-%E5%AF%B9%E9%A1%B6%E6%A0%88/</url>
    <content><![CDATA[<h1 id="故事开端"><a href="#故事开端" class="headerlink" title="故事开端"></a>故事开端</h1><p>  忆昔当年泪不干，在这么一个平凡的夜晚，我在牛客打了一发<a href="https://ac.nowcoder.com/acm/contest/73854">小白月赛</a>。当时的我并不知道这场比赛将会对现在的我造成多大的影响，以至于如今我时常怀念那个无所不能的自己。**</p>
<p><strong><del>（好像也不是很厉害）</del></strong></p>
<p><img src="%E6%AF%94%E8%B5%9B.jpg" alt="比赛"></p>
<p><strong>可以看到，七道题目我过了五题，水平还算好吧，看看最后两题过的人这么少（自豪）</strong></p>
<p><strong>好了也不多bb，开始进入正题</strong></p>
<h1 id="初次相遇"><a href="#初次相遇" class="headerlink" title="初次相遇"></a>初次相遇</h1><p><img src="%E6%8B%AC%E5%8F%B7%E5%BC%B1%E5%8C%96.png" alt="括号弱化"></p>
<p>我当时一看到这题，脑子里面浮现好几种做法，其中就有栈(有关栈的描述请看<a href="https://oi-wiki.org/lang/csl/container-adapter/">oi wiki 栈</a>)，但是最后我选择用数组来做，我也不知道我怎么想的，可能是因为以前在洛谷做过类似的题，比如<a href="https://www.luogu.com.cn/problem/P1739">P1739 表达式括号匹配</a>（用栈来验证左右括号是否完全匹配），就想用没做过的办法来写，于是就用了字符数组来做。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;bits/stdc++.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NO cout&lt;&lt;<span class="string">&quot;NO&quot;</span>&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> YES cout&lt;&lt;<span class="string">&quot;YES&quot;</span>&lt;&lt;endl</span></span><br><span class="line"><span class="type">char</span> a[<span class="number">2000500</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);cin.<span class="built_in">tie</span>(<span class="number">0</span>);cout.<span class="built_in">tie</span>(<span class="number">0</span>);<span class="comment">//解绑</span></span><br><span class="line">	<span class="type">int</span> n,k,num1,num2;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		cin&gt;&gt;a[i];</span><br><span class="line">		<span class="keyword">if</span>(a[i]==<span class="string">&#x27;I&#x27;</span>)<span class="comment">//记录光标位置，删掉左边括号就是num1--,删掉右边括号就是num2++，不用再处理中间的部分，也相当于“删除”</span></span><br><span class="line">			num1=i<span class="number">-1</span>,num2=i+<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++)&#123;</span><br><span class="line">		string b;</span><br><span class="line">		cin&gt;&gt;b;</span><br><span class="line">		<span class="keyword">if</span>(b==<span class="string">&quot;backspace&quot;</span>)&#123;</span><br><span class="line">            <span class="comment">//回车删除判断左右括号是否匹配</span></span><br><span class="line">			<span class="keyword">if</span>(a[num1]==<span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">				<span class="keyword">if</span>(a[num2]==<span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">					num1--;</span><br><span class="line">					num2++;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					num1--;</span><br><span class="line">			&#125;</span><br><span class="line">            <span class="comment">//判断光标左边的括号是右括号的情况</span></span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				<span class="keyword">if</span>(a[num1]==<span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">					num1--;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">//delete键删除，只会删除光标右边的括号，判断一下右边是否存在括号</span></span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(a[num2]==<span class="string">&#x27;(&#x27;</span>||a[num2]==<span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">				num2++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//顺序输出字符串</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=num1;i++)</span><br><span class="line">		cout&lt;&lt;a[i];</span><br><span class="line">	cout&lt;&lt;<span class="string">&#x27;I&#x27;</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=num2;i&lt;=n;i++)</span><br><span class="line">		cout&lt;&lt;a[i];	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>这题也是十分简单的一题，不过字符串的题总是特别会给自己加戏，比如这里一个特判那里一个特判，我就是因为忘记判断delete删除时光标右边是否存在括号直接wa2发，罚时上天，哭了OVO</strong></p>
<p><strong>本来做到这里我就想润了，因为我其实是一边打游戏一边比赛的，而且这题是第三题，已经浪费了我许多宝贵的游戏时间了，但是挑战自我的想法猛地从我内心窜出来，我决定再写十分钟</strong><del>（其实是不想被别人比下去）</del></p>
<h1 id="灵感大爆发"><a href="#灵感大爆发" class="headerlink" title="灵感大爆发!"></a>灵感大爆发!</h1><p><img src="%E6%8B%AC%E5%8F%B7%E5%BC%BA%E5%8C%96.png" alt="括号强化"></p>
<p><strong>一刻也没有为上一题哀悼，随着赶到战场的是——hard 删除括号！</strong></p>
<p><strong>这题相对于上题，难度就在于这个新增的操作：光标左右移。我当时觉得如果仍然采用上题的思路来写，会导致一个很棘手的问题：（以光标左边为例）光标左移后，原先的一个括号移动到光标右侧，那变动的这个括号该如何处理?（好像这玩意也可以用a[num2-1]来处理，然后num2- -，相当于变动的括号移到右边，不过我当时没想到这个，这个对不对我也没检验过）</strong></p>
<p><strong>然后我就想啊想，想了一会就想下播了，已经不想打力。然后我都打开游戏界面了，但突然想起来栈这玩意，我当时就在想，判断一序列括号是否合法不就可以用栈进出来做吗，脑海里就浮现出一张图，光标左移就是把左边的栈的栈顶取出，栈内括号数量减一，那这个出栈的括号又没有删除，怎么处理呢？那不就是放到右边的栈吗？！（此时把题目输入的字符串分为两个栈，一个栈存光标左边的括号，另一个存右边的括号，两个栈一个进栈序列是顺序，一个是逆序，就相当于两个栈的出口相对，也就是对顶栈）</strong></p>
<p><strong>来不及解释了，我一边思考着这个问题，一边敲代码测试，代码如下：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;bits/stdc++.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NO cout&lt;&lt;<span class="string">&quot;NO&quot;</span>&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> YES cout&lt;&lt;<span class="string">&quot;YES&quot;</span>&lt;&lt;endl</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);cin.<span class="built_in">tie</span>(<span class="number">0</span>);cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="type">int</span> n,k,flag=<span class="number">0</span>,num1,num2,num;</span><br><span class="line">	string c=<span class="string">&quot;&quot;</span>;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">	stack&lt;<span class="type">char</span>&gt; ds1,ds2;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="type">char</span> a;</span><br><span class="line">		cin&gt;&gt;a;</span><br><span class="line">		<span class="keyword">if</span>(a==<span class="string">&#x27;I&#x27;</span>)</span><br><span class="line">			flag=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(flag==<span class="number">0</span>)</span><br><span class="line">			ds1.<span class="built_in">push</span>(a);<span class="comment">//栈ds1存光标左边括号</span></span><br><span class="line">		<span class="keyword">if</span>(flag==<span class="number">1</span>&amp;&amp;a!=<span class="string">&#x27;I&#x27;</span>)</span><br><span class="line">			c+=a;<span class="comment">//存光标右边的所有括号</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=c.<span class="built_in">length</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">		ds2.<span class="built_in">push</span>(c[i]);<span class="comment">//将光标右边所有括号逆序存进栈ds2中，这样删除操作才是正确顺序</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++)&#123;</span><br><span class="line">		string b;<span class="comment">//b接收输入判断操作</span></span><br><span class="line">		cin&gt;&gt;b;</span><br><span class="line">		<span class="keyword">if</span>(b==<span class="string">&quot;backspace&quot;</span>)&#123;</span><br><span class="line">			<span class="type">char</span> tmp1=<span class="string">&#x27;1&#x27;</span>,tmp2=<span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">			<span class="keyword">if</span>(!ds1.<span class="built_in">empty</span>())<span class="comment">//回车删除判断左边括号是否存在，只要存在，不管左右是否对应，左边括号必须删除</span></span><br><span class="line">				tmp1=ds1.<span class="built_in">top</span>(),ds1.<span class="built_in">pop</span>();</span><br><span class="line">			<span class="keyword">if</span>(!ds2.<span class="built_in">empty</span>())<span class="comment">//判断右边括号是否存在</span></span><br><span class="line">				tmp2=ds2.<span class="built_in">top</span>();</span><br><span class="line">			<span class="keyword">if</span>(tmp1==<span class="string">&#x27;(&#x27;</span>&amp;&amp;tmp2==<span class="string">&#x27;)&#x27;</span>)<span class="comment">//判断左右括号配对</span></span><br><span class="line">				ds2.<span class="built_in">pop</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(b==<span class="string">&quot;delete&quot;</span>)&#123;<span class="comment">//delete只用判断右边括号是否存在</span></span><br><span class="line">			<span class="keyword">if</span>(!ds2.<span class="built_in">empty</span>())</span><br><span class="line">				ds2.<span class="built_in">pop</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(b==<span class="string">&quot;&lt;-&quot;</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>(!ds1.<span class="built_in">empty</span>())&#123;<span class="comment">//左移，左边括号出栈，进到右边的栈，没括号就不移</span></span><br><span class="line">				<span class="type">char</span> tmp1=ds1.<span class="built_in">top</span>();</span><br><span class="line">				ds1.<span class="built_in">pop</span>();</span><br><span class="line">				ds2.<span class="built_in">push</span>(tmp1);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(!ds2.<span class="built_in">empty</span>())&#123;<span class="comment">//右移，右边括号出栈，进到左边的栈，没括号就不移</span></span><br><span class="line">				<span class="type">char</span> tmp1=ds2.<span class="built_in">top</span>();</span><br><span class="line">				ds2.<span class="built_in">pop</span>();</span><br><span class="line">				ds1.<span class="built_in">push</span>(tmp1);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	string a=<span class="string">&quot;&quot;</span>,b=<span class="string">&quot;&quot;</span>;<span class="comment">//栈ds1的出栈序列是反的，所以需要字符串存一下再逆序输出</span></span><br><span class="line">	<span class="keyword">while</span>(!ds1.<span class="built_in">empty</span>())&#123;</span><br><span class="line">		<span class="type">char</span> tmp=ds1.<span class="built_in">top</span>();</span><br><span class="line">		a+=tmp;</span><br><span class="line">		ds1.<span class="built_in">pop</span>(); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=a.<span class="built_in">length</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">		cout&lt;&lt;a[i];</span><br><span class="line">	cout&lt;&lt;<span class="string">&#x27;I&#x27;</span>;<span class="comment">//光标处于两个栈中间</span></span><br><span class="line">	<span class="keyword">while</span>(!ds2.<span class="built_in">empty</span>())&#123;<span class="comment">//栈ds2进栈序列是反的，那出栈序列就是正的，直接出栈输出</span></span><br><span class="line">		<span class="type">char</span> tmp=ds2.<span class="built_in">top</span>();</span><br><span class="line">		cout&lt;&lt;tmp;</span><br><span class="line">		ds2.<span class="built_in">pop</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第一次交的时候wa了，当时我心脏都停跳了，这么完美的想法居然是错的？本着写都写了的理念，我开始找样例调试，然后发现：我当时ds2也用了一个字符串存出栈序列来逆序输出，这就导致了光标右边的括号都是反的，而题目给的样例都是要么括号删完了，要么光标移动到最右边了，所以能过样例。改完之后我忐忑地点了提交，过了几秒就出现那个死牛和死人音效，悬着的心终于放下来了O.o</strong></p>
<p><img src="%E6%AD%BB%E7%89%9B.png" alt="死牛"></p>
<h1 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h1><p><strong>总的来说，这两道字符串其实不是很难，只要你能想到怎么处理那就很简单了，但是赛场上能及时想出正确的解法也是一件不容易的事，事后我去看了讲解，才知道我写的这玩意叫对顶栈，很简单的栈的运用，但是是我在比赛中灵感一现写出来的，对我来说也有很大的纪念意义，写这篇文章也算是回顾比赛加深知识理解了，以后我还会记录更多的奇思妙想，加纳。</strong></p>
]]></content>
      <tags>
        <tag>入门</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>排序</title>
    <url>/2024/03/17/%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>  <strong>排序算法</strong>（英语：Sorting algorithm）是一种将一组特定的数据按某种顺序进行排列的算法。排序算法多种多样，性质也大多不同。</p>
<p>  排序算法的种类很多，例如选择排序，冒泡排序，插入排序，基数排序，快速排序，归并排序，堆排序，桶排序……</p>
<p>  不同种类的排序算法用途一般不同，不过最常用的无非就是快速排序和sort函数排序，后者更是基本适用所有情况，接下来我要介绍的几种排序算法中也会着重介绍他们。</p>
<h2 id="选择排序和冒泡排序"><a href="#选择排序和冒泡排序" class="headerlink" title="选择排序和冒泡排序"></a>选择排序和冒泡排序</h2><p>  选择排序是一种十分直观的排序算法，大概就是在第i次循环中选中未排序元素中最小的元素，将其放到数组第i位，并进入下一轮寻找最小元素的循环中。</p>
<p>  大致代码如下:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;iostream&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> n=<span class="number">4</span>;</span><br><span class="line">	<span class="type">int</span> a[<span class="number">5</span>]=&#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    <span class="comment">//前n-1个元素排序完了，第n个元素就自动排序好了，并且这里数组下标从0开始，故循环至n-1</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">		<span class="type">int</span> mi=a[i],xb=i; <span class="comment">//设置最小值和最小值元素对应下标 </span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">			<span class="keyword">if</span>(a[j]&lt;mi)&#123;</span><br><span class="line">				mi=a[j];</span><br><span class="line">				xb=j;</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="comment">//交换元素 </span></span><br><span class="line">		<span class="type">int</span> tmp=a[i];</span><br><span class="line">		a[i]=a[xb];</span><br><span class="line">		a[xb]=tmp; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">		cout&lt;&lt;a[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  这段代码运行结果如下：</p>
<p>  1 3 4 5 9</p>
<p>  可以看到，数组元素被正确排序了，尽管如此，选择排序并不是最符合我们要求的算法。</p>
<p>  原因有二：</p>
<p>  其一，不稳定性。选择排序的结果是对的，但是过程中数组元素并不是有序的，例如上述代码，最初数组元素为 1 5 4 9 3，第一轮排序，1是最小，数组元素相对大小顺序不会发生改变，但第二轮排序，3是最小，与5交换，数组元素变成1 3 4 9 5，5应该在9之前才是有序的，但在这里变成了5在9后面，打乱了未排序元素的相对大小顺序。</p>
<p>  其二，糟糕的时间复杂度，可以看到，在代码中我们使用了两个循环，并且循环次数都可以近似看成n，也就是说，选择排序的时间复杂度是O(n²)，对于元素有几十万甚至更多的数组，排序时间是远远超出了限定时间的。</p>
<p>  同样，冒泡排序的时间复杂度也是O(n²)，但它与选择排序不同的是，选择排序每轮寻找最小值，冒泡排序每轮寻找最大值。</p>
<p>  代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;iostream&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> n=<span class="number">4</span>;</span><br><span class="line">	<span class="type">int</span> a[<span class="number">5</span>]=&#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">3</span>&#125;;</span><br><span class="line">	<span class="comment">//最外轮循环代表循环次数 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="comment">//如果有i-1个元素排序好了，后面i个元素就不用再遍历了 </span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n-i;j++)</span><br><span class="line">			<span class="comment">//相邻元素比较大小交换 </span></span><br><span class="line">			<span class="keyword">if</span>(a[j]&gt;a[j+<span class="number">1</span>])&#123;</span><br><span class="line">				<span class="type">int</span> tmp=a[j];</span><br><span class="line">				a[j]=a[j+<span class="number">1</span>];</span><br><span class="line">				a[j+<span class="number">1</span>]=tmp;</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">		cout&lt;&lt;a[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  结果显然易见:1 3 4 5 9。</p>
<p>  为什么叫冒泡排序呢？如果第一个元素最大，那他在第一轮排序与每个相邻元素都要交换，最后成为数组最后一位元素，这一轮排序全部操作列出来，第一个元素就像在逐渐沉底，那它反过来就是逐渐上升，像气泡逐渐上升冒出水面，故曰：冒泡排序。</p>
<p>  选择排序具有不稳定性，但冒泡排序却具有稳定性，因为一定是比当前元素大的元素排在当前元素右边，原本相对大小顺序并不会改变。</p>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>  重头戏登场，没有时间为选择排序和冒泡排序的超时哀悼，随之赶到OJ的是——快速排序。</p>
<p>  快速排序从两头同时排序，采用分治方法，最优情况下稳定的O(nlogn)时间复杂度简直薄纱上面两个排序算法，虽然最坏情况下时间复杂度仍是O(n²)，但在使用情况中基本不可能出现最坏情况，可以说它的时间复杂度就是O(nlogn)。</p>
<p>  快排的思路就是：选中当前数组左端点i&#x3D;l和右端点j&#x3D;r以及分界点元素a[(l+r)&#x2F;2]也就是最中间的元素，每次用while寻找i到中点的第一个大于分界点的元素，再用while循环寻找j到中点的第一个小于分界点的元素，如果i和j没有越过中点即i&lt;&#x3D;j，交换他们的值，排序完后，左端点到中点的元素都小于分界点，中点到右端点的元素都大于分界点，但是，他们这时还不是有序的，比如2 1 3 4 8 9 7，那怎么办呢？那还不简单，接着排序呗，这时排序就不用从最开始的左端点到右端点排序了，之前j–,如果j没有超过左端点l,那我们就可以把j作为右端点，同理如果i没有超过右端点r，i就可以作为新的左端点，调用自身，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">qsort</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> i=l,j=r,mid=a[(i+j)/<span class="number">2</span>];</span><br><span class="line">	<span class="keyword">do</span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(a[j]&gt;mid) j--;</span><br><span class="line">		<span class="keyword">while</span>(a[i]&lt;mid) i++;</span><br><span class="line">		<span class="keyword">if</span>(i&lt;=j)&#123;</span><br><span class="line">			<span class="type">int</span> temp=a[j];</span><br><span class="line">			a[j]=a[i];</span><br><span class="line">			a[i]=temp;</span><br><span class="line">			i++;</span><br><span class="line">			j--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;<span class="keyword">while</span>(i&lt;=j);</span><br><span class="line">	<span class="keyword">if</span>(i&lt;r) <span class="built_in">qsort</span>(a,i,r);</span><br><span class="line">	<span class="keyword">if</span>(l&lt;j) <span class="built_in">qsort</span>(a,l,j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>值得一提,qsort(num, n, sizeof(int), cmp)是stdlib.h头文件内的函数,也是c语言中唯二涉及算法的函数,另一个是二分，这里不讲喵。</p>
<h2 id="sort函数排序"><a href="#sort函数排序" class="headerlink" title="sort函数排序"></a>sort函数排序</h2><p>经典中的经典，algorithm头文件中自带的排序函数，适用范围极广，只要有排序的地方他就能排上用场，犹如亚里士多德般的全能感，令我的大脑旋转。</p>
<p>sort函数由快排和堆排优化实现，时间复杂度稳定在nlogn,使用起来十分方便，格式如下:</p>
<p>sort(begin, end, cmp)</p>
<p>总共有三个参数，前面两个分别代表待排序数组的开头和结尾，并不一定是0到n-1或者1到n，你可以做到数组中间排序而前后不排序，第三个参数是排序准则，这个参数可以把你自定义的函数加进去，比如说sort函数默认从小到大排序，如果你想要从大到小排序，可以自定义一个cmp函数，如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//这里也可以是int类型 </span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x&gt;y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//设置两个相同的数组 </span></span><br><span class="line">	<span class="type">int</span> a[<span class="number">5</span>]=&#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>&#125;;</span><br><span class="line">	<span class="type">int</span> b[<span class="number">5</span>]=&#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>&#125;;</span><br><span class="line">	<span class="comment">//a数组用原本的sort函数排序 </span></span><br><span class="line">	<span class="built_in">sort</span>(a,a+<span class="number">5</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">		cout&lt;&lt;a[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line">	<span class="comment">//b数组用加了自定义函数的sort函数排序 </span></span><br><span class="line">	<span class="built_in">sort</span>(b,b+<span class="number">5</span>,cmp);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">		cout&lt;&lt;b[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<p><img src="%E8%BE%93%E5%87%BA.png" alt="输出"></p>
<p>可以看到，b数组实现了我们所要的从大到小排序。</p>
<h3 id="sort函数对结构体排序"><a href="#sort函数对结构体排序" class="headerlink" title="sort函数对结构体排序"></a>sort函数对结构体排序</h3><p>上面提到sort函数适用范围很广，对结构体也不例外，但结构体内包含多个变量，该如何进行排序呢？</p>
<p>很简单，我们照样自定义一个cmp函数，确定一个变量或者多个变量作为排序标准，这时候cmp函数的参数就是结构体了。</p>
<p>例如，我手上有一批学生的姓名，学号和成绩，我想把他们成绩从大到小排序，如果成绩相同，学号小的优先，那么，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span>&#123;</span><br><span class="line">	<span class="comment">//学号一般都是八位或者八位以上，用int可能会爆，用long long太占空间，所以用字符串表示 </span></span><br><span class="line">	string name,xuehao;</span><br><span class="line">	<span class="type">int</span> score;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(student x,student y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x.score!=y.score)</span><br><span class="line">		<span class="keyword">return</span> x.score&gt;y.score;</span><br><span class="line">	<span class="comment">//字符串也是可以比较的，通过比较第一个不相同字符的字典序来判断大小 </span></span><br><span class="line">	<span class="keyword">return</span> x.xuehao&lt;y.xuehao;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	student a[<span class="number">4</span>];</span><br><span class="line">	<span class="comment">//设置四个学生信息 </span></span><br><span class="line">	a[<span class="number">0</span>].name=<span class="string">&quot;dingbudele&quot;</span>,a[<span class="number">0</span>].xuehao=<span class="string">&quot;114515&quot;</span>,a[<span class="number">0</span>].score=<span class="number">750</span>;</span><br><span class="line">	a[<span class="number">1</span>].name=<span class="string">&quot;ewoji&quot;</span>,a[<span class="number">1</span>].xuehao=<span class="string">&quot;114514&quot;</span>,a[<span class="number">1</span>].score=<span class="number">750</span>;</span><br><span class="line">	a[<span class="number">2</span>].name=<span class="string">&quot;niganma&quot;</span>,a[<span class="number">2</span>].xuehao=<span class="string">&quot;114511&quot;</span>,a[<span class="number">2</span>].score=<span class="number">666</span>;</span><br><span class="line">	a[<span class="number">3</span>].name=<span class="string">&quot;zhendeshinia&quot;</span>,a[<span class="number">3</span>].xuehao=<span class="string">&quot;114512&quot;</span>,a[<span class="number">3</span>].score=<span class="number">99</span>;</span><br><span class="line">	<span class="built_in">sort</span>(a,a+<span class="number">4</span>,cmp);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">		cout&lt;&lt;a[i].name&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;a[i].xuehao&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;a[i].score&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<p><img src="%E7%BB%93%E6%9E%84%E4%BD%93%E6%8E%92%E5%BA%8F%E8%BE%93%E5%87%BA.png" alt="结构体排序输出"></p>
<p>可以看到成绩高的在前面，并且成绩相同时学号小的在前面喵，恭喜学号为114514的同学夺得第一，OVO。</p>
]]></content>
      <tags>
        <tag>入门</tag>
        <tag>算法</tag>
      </tags>
  </entry>
</search>
