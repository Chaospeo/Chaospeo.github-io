<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>失败</title>
    <url>/2024/05/09/%E5%A4%B1%E8%B4%A5/</url>
    <content><![CDATA[<p><img src="../_posts/%E5%A4%B1%E8%B4%A5/%E6%AF%94%E8%B5%9B-1715263258277.jpg" alt="比赛"></p>
]]></content>
      <tags>
        <tag>失败</tag>
      </tags>
  </entry>
  <entry>
    <title>灵光一闪--对顶栈</title>
    <url>/2024/03/08/%E7%81%B5%E5%85%89%E4%B8%80%E9%97%AA-%E5%AF%B9%E9%A1%B6%E6%A0%88/</url>
    <content><![CDATA[<h1 id="故事开端"><a href="#故事开端" class="headerlink" title="故事开端"></a>故事开端</h1><p>  忆昔当年泪不干，在这么一个平凡的夜晚，我在牛客打了一发<a href="https://ac.nowcoder.com/acm/contest/73854">小白月赛</a>。当时的我并不知道这场比赛将会对现在的我造成多大的影响，以至于如今我时常怀念那个无所不能的自己。**</p>
<p><strong><del>（好像也不是很厉害）</del></strong></p>
<p><img src="%E6%AF%94%E8%B5%9B.jpg" alt="比赛"></p>
<p><strong>可以看到，七道题目我过了五题，水平还算好吧，看看最后两题过的人这么少（自豪）</strong></p>
<p><strong>好了也不多bb，开始进入正题</strong></p>
<h1 id="初次相遇"><a href="#初次相遇" class="headerlink" title="初次相遇"></a>初次相遇</h1><p><img src="%E6%8B%AC%E5%8F%B7%E5%BC%B1%E5%8C%96.png" alt="括号弱化"></p>
<p>我当时一看到这题，脑子里面浮现好几种做法，其中就有栈(有关栈的描述请看<a href="https://oi-wiki.org/lang/csl/container-adapter/">oi wiki 栈</a>)，但是最后我选择用数组来做，我也不知道我怎么想的，可能是因为以前在洛谷做过类似的题，比如<a href="https://www.luogu.com.cn/problem/P1739">P1739 表达式括号匹配</a>（用栈来验证左右括号是否完全匹配），就想用没做过的办法来写，于是就用了字符数组来做。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;bits/stdc++.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NO cout&lt;&lt;<span class="string">&quot;NO&quot;</span>&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> YES cout&lt;&lt;<span class="string">&quot;YES&quot;</span>&lt;&lt;endl</span></span><br><span class="line"><span class="type">char</span> a[<span class="number">2000500</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);cin.<span class="built_in">tie</span>(<span class="number">0</span>);cout.<span class="built_in">tie</span>(<span class="number">0</span>);<span class="comment">//解绑</span></span><br><span class="line">	<span class="type">int</span> n,k,num1,num2;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		cin&gt;&gt;a[i];</span><br><span class="line">		<span class="keyword">if</span>(a[i]==<span class="string">&#x27;I&#x27;</span>)<span class="comment">//记录光标位置，删掉左边括号就是num1--,删掉右边括号就是num2++，不用再处理中间的部分，也相当于“删除”</span></span><br><span class="line">			num1=i<span class="number">-1</span>,num2=i+<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++)&#123;</span><br><span class="line">		string b;</span><br><span class="line">		cin&gt;&gt;b;</span><br><span class="line">		<span class="keyword">if</span>(b==<span class="string">&quot;backspace&quot;</span>)&#123;</span><br><span class="line">            <span class="comment">//回车删除判断左右括号是否匹配</span></span><br><span class="line">			<span class="keyword">if</span>(a[num1]==<span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">				<span class="keyword">if</span>(a[num2]==<span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">					num1--;</span><br><span class="line">					num2++;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					num1--;</span><br><span class="line">			&#125;</span><br><span class="line">            <span class="comment">//判断光标左边的括号是右括号的情况</span></span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				<span class="keyword">if</span>(a[num1]==<span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">					num1--;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">//delete键删除，只会删除光标右边的括号，判断一下右边是否存在括号</span></span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(a[num2]==<span class="string">&#x27;(&#x27;</span>||a[num2]==<span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">				num2++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//顺序输出字符串</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=num1;i++)</span><br><span class="line">		cout&lt;&lt;a[i];</span><br><span class="line">	cout&lt;&lt;<span class="string">&#x27;I&#x27;</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=num2;i&lt;=n;i++)</span><br><span class="line">		cout&lt;&lt;a[i];	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>这题也是十分简单的一题，不过字符串的题总是特别会给自己加戏，比如这里一个特判那里一个特判，我就是因为忘记判断delete删除时光标右边是否存在括号直接wa2发，罚时上天，哭了OVO</strong></p>
<p><strong>本来做到这里我就想润了，因为我其实是一边打游戏一边比赛的，而且这题是第三题，已经浪费了我许多宝贵的游戏时间了，但是挑战自我的想法猛地从我内心窜出来，我决定再写十分钟</strong><del>（其实是不想被别人比下去）</del></p>
<h1 id="灵感大爆发"><a href="#灵感大爆发" class="headerlink" title="灵感大爆发!"></a>灵感大爆发!</h1><p><img src="%E6%8B%AC%E5%8F%B7%E5%BC%BA%E5%8C%96.png" alt="括号强化"></p>
<p><strong>一刻也没有为上一题哀悼，随着赶到战场的是——hard 删除括号！</strong></p>
<p><strong>这题相对于上题，难度就在于这个新增的操作：光标左右移。我当时觉得如果仍然采用上题的思路来写，会导致一个很棘手的问题：（以光标左边为例）光标左移后，原先的一个括号移动到光标右侧，那变动的这个括号该如何处理?（好像这玩意也可以用a[num2-1]来处理，然后num2- -，相当于变动的括号移到右边，不过我当时没想到这个，这个对不对我也没检验过）</strong></p>
<p><strong>然后我就想啊想，想了一会就想下播了，已经不想打力。然后我都打开游戏界面了，但突然想起来栈这玩意，我当时就在想，判断一序列括号是否合法不就可以用栈进出来做吗，脑海里就浮现出一张图，光标左移就是把左边的栈的栈顶取出，栈内括号数量减一，那这个出栈的括号又没有删除，怎么处理呢？那不就是放到右边的栈吗？！（此时把题目输入的字符串分为两个栈，一个栈存光标左边的括号，另一个存右边的括号，两个栈一个进栈序列是顺序，一个是逆序，就相当于两个栈的出口相对，也就是对顶栈）</strong></p>
<p><strong>来不及解释了，我一边思考着这个问题，一边敲代码测试，代码如下：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;bits/stdc++.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NO cout&lt;&lt;<span class="string">&quot;NO&quot;</span>&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> YES cout&lt;&lt;<span class="string">&quot;YES&quot;</span>&lt;&lt;endl</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);cin.<span class="built_in">tie</span>(<span class="number">0</span>);cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="type">int</span> n,k,flag=<span class="number">0</span>,num1,num2,num;</span><br><span class="line">	string c=<span class="string">&quot;&quot;</span>;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">	stack&lt;<span class="type">char</span>&gt; ds1,ds2;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="type">char</span> a;</span><br><span class="line">		cin&gt;&gt;a;</span><br><span class="line">		<span class="keyword">if</span>(a==<span class="string">&#x27;I&#x27;</span>)</span><br><span class="line">			flag=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(flag==<span class="number">0</span>)</span><br><span class="line">			ds1.<span class="built_in">push</span>(a);<span class="comment">//栈ds1存光标左边括号</span></span><br><span class="line">		<span class="keyword">if</span>(flag==<span class="number">1</span>&amp;&amp;a!=<span class="string">&#x27;I&#x27;</span>)</span><br><span class="line">			c+=a;<span class="comment">//存光标右边的所有括号</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=c.<span class="built_in">length</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">		ds2.<span class="built_in">push</span>(c[i]);<span class="comment">//将光标右边所有括号逆序存进栈ds2中，这样删除操作才是正确顺序</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++)&#123;</span><br><span class="line">		string b;<span class="comment">//b接收输入判断操作</span></span><br><span class="line">		cin&gt;&gt;b;</span><br><span class="line">		<span class="keyword">if</span>(b==<span class="string">&quot;backspace&quot;</span>)&#123;</span><br><span class="line">			<span class="type">char</span> tmp1=<span class="string">&#x27;1&#x27;</span>,tmp2=<span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">			<span class="keyword">if</span>(!ds1.<span class="built_in">empty</span>())<span class="comment">//回车删除判断左边括号是否存在，只要存在，不管左右是否对应，左边括号必须删除</span></span><br><span class="line">				tmp1=ds1.<span class="built_in">top</span>(),ds1.<span class="built_in">pop</span>();</span><br><span class="line">			<span class="keyword">if</span>(!ds2.<span class="built_in">empty</span>())<span class="comment">//判断右边括号是否存在</span></span><br><span class="line">				tmp2=ds2.<span class="built_in">top</span>();</span><br><span class="line">			<span class="keyword">if</span>(tmp1==<span class="string">&#x27;(&#x27;</span>&amp;&amp;tmp2==<span class="string">&#x27;)&#x27;</span>)<span class="comment">//判断左右括号配对</span></span><br><span class="line">				ds2.<span class="built_in">pop</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(b==<span class="string">&quot;delete&quot;</span>)&#123;<span class="comment">//delete只用判断右边括号是否存在</span></span><br><span class="line">			<span class="keyword">if</span>(!ds2.<span class="built_in">empty</span>())</span><br><span class="line">				ds2.<span class="built_in">pop</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(b==<span class="string">&quot;&lt;-&quot;</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>(!ds1.<span class="built_in">empty</span>())&#123;<span class="comment">//左移，左边括号出栈，进到右边的栈，没括号就不移</span></span><br><span class="line">				<span class="type">char</span> tmp1=ds1.<span class="built_in">top</span>();</span><br><span class="line">				ds1.<span class="built_in">pop</span>();</span><br><span class="line">				ds2.<span class="built_in">push</span>(tmp1);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(!ds2.<span class="built_in">empty</span>())&#123;<span class="comment">//右移，右边括号出栈，进到左边的栈，没括号就不移</span></span><br><span class="line">				<span class="type">char</span> tmp1=ds2.<span class="built_in">top</span>();</span><br><span class="line">				ds2.<span class="built_in">pop</span>();</span><br><span class="line">				ds1.<span class="built_in">push</span>(tmp1);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	string a=<span class="string">&quot;&quot;</span>,b=<span class="string">&quot;&quot;</span>;<span class="comment">//栈ds1的出栈序列是反的，所以需要字符串存一下再逆序输出</span></span><br><span class="line">	<span class="keyword">while</span>(!ds1.<span class="built_in">empty</span>())&#123;</span><br><span class="line">		<span class="type">char</span> tmp=ds1.<span class="built_in">top</span>();</span><br><span class="line">		a+=tmp;</span><br><span class="line">		ds1.<span class="built_in">pop</span>(); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=a.<span class="built_in">length</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">		cout&lt;&lt;a[i];</span><br><span class="line">	cout&lt;&lt;<span class="string">&#x27;I&#x27;</span>;<span class="comment">//光标处于两个栈中间</span></span><br><span class="line">	<span class="keyword">while</span>(!ds2.<span class="built_in">empty</span>())&#123;<span class="comment">//栈ds2进栈序列是反的，那出栈序列就是正的，直接出栈输出</span></span><br><span class="line">		<span class="type">char</span> tmp=ds2.<span class="built_in">top</span>();</span><br><span class="line">		cout&lt;&lt;tmp;</span><br><span class="line">		ds2.<span class="built_in">pop</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第一次交的时候wa了，当时我心脏都停跳了，这么完美的想法居然是错的？本着写都写了的理念，我开始找样例调试，然后发现：我当时ds2也用了一个字符串存出栈序列来逆序输出，这就导致了光标右边的括号都是反的，而题目给的样例都是要么括号删完了，要么光标移动到最右边了，所以能过样例。改完之后我忐忑地点了提交，过了几秒就出现那个死牛和死人音效，悬着的心终于放下来了O.o</strong></p>
<p><img src="%E6%AD%BB%E7%89%9B.png" alt="死牛"></p>
<h1 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h1><p><strong>总的来说，这两道字符串其实不是很难，只要你能想到怎么处理那就很简单了，但是赛场上能及时想出正确的解法也是一件不容易的事，事后我去看了讲解，才知道我写的这玩意叫对顶栈，很简单的栈的运用，但是是我在比赛中灵感一现写出来的，对我来说也有很大的纪念意义，写这篇文章也算是回顾比赛加深知识理解了，以后我还会记录更多的奇思妙想，加纳。</strong></p>
]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>入门</tag>
      </tags>
  </entry>
  <entry>
    <title>排序</title>
    <url>/2024/03/17/%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>  <strong>排序算法</strong>（英语：Sorting algorithm）是一种将一组特定的数据按某种顺序进行排列的算法。排序算法多种多样，性质也大多不同。</p>
<p>  排序算法的种类很多，例如选择排序，冒泡排序，插入排序，基数排序，快速排序，归并排序，堆排序，桶排序……</p>
<p>  不同种类的排序算法用途一般不同，不过最常用的无非就是快速排序和sort函数排序，后者更是基本适用所有情况，接下来我要介绍的几种排序算法中也会着重介绍他们。</p>
<h2 id="选择排序和冒泡排序"><a href="#选择排序和冒泡排序" class="headerlink" title="选择排序和冒泡排序"></a>选择排序和冒泡排序</h2><p>  选择排序是一种十分直观的排序算法，大概就是在第i次循环中选中未排序元素中最小的元素，将其放到数组第i位，并进入下一轮寻找最小元素的循环中。</p>
<p>  大致代码如下:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;iostream&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> n=<span class="number">4</span>;</span><br><span class="line">	<span class="type">int</span> a[<span class="number">5</span>]=&#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    <span class="comment">//前n-1个元素排序完了，第n个元素就自动排序好了，并且这里数组下标从0开始，故循环至n-1</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">		<span class="type">int</span> mi=a[i],xb=i; <span class="comment">//设置最小值和最小值元素对应下标 </span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">			<span class="keyword">if</span>(a[j]&lt;mi)&#123;</span><br><span class="line">				mi=a[j];</span><br><span class="line">				xb=j;</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="comment">//交换元素 </span></span><br><span class="line">		<span class="type">int</span> tmp=a[i];</span><br><span class="line">		a[i]=a[xb];</span><br><span class="line">		a[xb]=tmp; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">		cout&lt;&lt;a[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  这段代码运行结果如下：</p>
<p>  1 3 4 5 9</p>
<p>  可以看到，数组元素被正确排序了，尽管如此，选择排序并不是最符合我们要求的算法。</p>
<p>  原因有二：</p>
<p>  其一，不稳定性。选择排序的结果是对的，但是过程中数组元素并不是有序的，例如上述代码，最初数组元素为 1 5 4 9 3，第一轮排序，1是最小，数组元素相对大小顺序不会发生改变，但第二轮排序，3是最小，与5交换，数组元素变成1 3 4 9 5，5应该在9之前才是有序的，但在这里变成了5在9后面，打乱了未排序元素的相对大小顺序。</p>
<p>  其二，糟糕的时间复杂度，可以看到，在代码中我们使用了两个循环，并且循环次数都可以近似看成n，也就是说，选择排序的时间复杂度是O(n²)，对于元素有几十万甚至更多的数组，排序时间是远远超出了限定时间的。</p>
<p>  同样，冒泡排序的时间复杂度也是O(n²)，但它与选择排序不同的是，选择排序每轮寻找最小值，冒泡排序每轮寻找最大值。</p>
<p>  代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;iostream&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> n=<span class="number">4</span>;</span><br><span class="line">	<span class="type">int</span> a[<span class="number">5</span>]=&#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">3</span>&#125;;</span><br><span class="line">	<span class="comment">//最外轮循环代表循环次数 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="comment">//如果有i-1个元素排序好了，后面i个元素就不用再遍历了 </span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n-i;j++)</span><br><span class="line">			<span class="comment">//相邻元素比较大小交换 </span></span><br><span class="line">			<span class="keyword">if</span>(a[j]&gt;a[j+<span class="number">1</span>])&#123;</span><br><span class="line">				<span class="type">int</span> tmp=a[j];</span><br><span class="line">				a[j]=a[j+<span class="number">1</span>];</span><br><span class="line">				a[j+<span class="number">1</span>]=tmp;</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">		cout&lt;&lt;a[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  结果显然易见:1 3 4 5 9。</p>
<p>  为什么叫冒泡排序呢？如果第一个元素最大，那他在第一轮排序与每个相邻元素都要交换，最后成为数组最后一位元素，这一轮排序全部操作列出来，第一个元素就像在逐渐沉底，那它反过来就是逐渐上升，像气泡逐渐上升冒出水面，故曰：冒泡排序。</p>
<p>  选择排序具有不稳定性，但冒泡排序却具有稳定性，因为一定是比当前元素大的元素排在当前元素右边，原本相对大小顺序并不会改变。</p>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>  重头戏登场，没有时间为选择排序和冒泡排序的超时哀悼，随之赶到OJ的是——快速排序。</p>
<p>  快速排序从两头同时排序，采用分治方法，最优情况下稳定的O(nlogn)时间复杂度简直薄纱上面两个排序算法，虽然最坏情况下时间复杂度仍是O(n²)，但在使用情况中基本不可能出现最坏情况，可以说它的时间复杂度就是O(nlogn)。</p>
<p>  快排的思路就是：选中当前数组左端点i&#x3D;l和右端点j&#x3D;r以及分界点元素a[(l+r)&#x2F;2]也就是最中间的元素，每次用while寻找i到中点的第一个大于分界点的元素，再用while循环寻找j到中点的第一个小于分界点的元素，如果i和j没有越过中点即i&lt;&#x3D;j，交换他们的值，排序完后，左端点到中点的元素都小于分界点，中点到右端点的元素都大于分界点，但是，他们这时还不是有序的，比如2 1 3 4 8 9 7，那怎么办呢？那还不简单，接着排序呗，这时排序就不用从最开始的左端点到右端点排序了，之前j–,如果j没有超过左端点l,那我们就可以把j作为右端点，同理如果i没有超过右端点r，i就可以作为新的左端点，调用自身，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">qsort</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> i=l,j=r,mid=a[(i+j)/<span class="number">2</span>];</span><br><span class="line">	<span class="keyword">do</span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(a[j]&gt;mid) j--;</span><br><span class="line">		<span class="keyword">while</span>(a[i]&lt;mid) i++;</span><br><span class="line">		<span class="keyword">if</span>(i&lt;=j)&#123;</span><br><span class="line">			<span class="type">int</span> temp=a[j];</span><br><span class="line">			a[j]=a[i];</span><br><span class="line">			a[i]=temp;</span><br><span class="line">			i++;</span><br><span class="line">			j--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;<span class="keyword">while</span>(i&lt;=j);</span><br><span class="line">	<span class="keyword">if</span>(i&lt;r) <span class="built_in">qsort</span>(a,i,r);</span><br><span class="line">	<span class="keyword">if</span>(l&lt;j) <span class="built_in">qsort</span>(a,l,j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>值得一提,qsort(num, n, sizeof(int), cmp)是stdlib.h头文件内的函数,也是c语言中唯二涉及算法的函数,另一个是二分，这里不讲喵。</p>
<h2 id="sort函数排序"><a href="#sort函数排序" class="headerlink" title="sort函数排序"></a>sort函数排序</h2><p>经典中的经典，algorithm头文件中自带的排序函数，适用范围极广，只要有排序的地方他就能排上用场，犹如亚里士多德般的全能感，令我的大脑旋转。</p>
<p>sort函数由快排和堆排优化实现，时间复杂度稳定在nlogn,使用起来十分方便，格式如下:</p>
<p>sort(begin, end, cmp)</p>
<p>总共有三个参数，前面两个分别代表待排序数组的开头和结尾，并不一定是0到n-1或者1到n，你可以做到数组中间排序而前后不排序，第三个参数是排序准则，这个参数可以把你自定义的函数加进去，比如说sort函数默认从小到大排序，如果你想要从大到小排序，可以自定义一个cmp函数，如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//这里也可以是int类型 </span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x&gt;y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//设置两个相同的数组 </span></span><br><span class="line">	<span class="type">int</span> a[<span class="number">5</span>]=&#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>&#125;;</span><br><span class="line">	<span class="type">int</span> b[<span class="number">5</span>]=&#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>&#125;;</span><br><span class="line">	<span class="comment">//a数组用原本的sort函数排序 </span></span><br><span class="line">	<span class="built_in">sort</span>(a,a+<span class="number">5</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">		cout&lt;&lt;a[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line">	<span class="comment">//b数组用加了自定义函数的sort函数排序 </span></span><br><span class="line">	<span class="built_in">sort</span>(b,b+<span class="number">5</span>,cmp);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">		cout&lt;&lt;b[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<p><img src="%E8%BE%93%E5%87%BA.png" alt="输出"></p>
<p>可以看到，b数组实现了我们所要的从大到小排序。</p>
<h3 id="sort函数对结构体排序"><a href="#sort函数对结构体排序" class="headerlink" title="sort函数对结构体排序"></a>sort函数对结构体排序</h3><p>上面提到sort函数适用范围很广，对结构体也不例外，但结构体内包含多个变量，该如何进行排序呢？</p>
<p>很简单，我们照样自定义一个cmp函数，确定一个变量或者多个变量作为排序标准，这时候cmp函数的参数就是结构体了。</p>
<p>例如，我手上有一批学生的姓名，学号和成绩，我想把他们成绩从大到小排序，如果成绩相同，学号小的优先，那么，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span>&#123;</span><br><span class="line">	<span class="comment">//学号一般都是八位或者八位以上，用int可能会爆，用long long太占空间，所以用字符串表示 </span></span><br><span class="line">	string name,xuehao;</span><br><span class="line">	<span class="type">int</span> score;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(student x,student y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x.score!=y.score)</span><br><span class="line">		<span class="keyword">return</span> x.score&gt;y.score;</span><br><span class="line">	<span class="comment">//字符串也是可以比较的，通过比较第一个不相同字符的字典序来判断大小 </span></span><br><span class="line">	<span class="keyword">return</span> x.xuehao&lt;y.xuehao;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	student a[<span class="number">4</span>];</span><br><span class="line">	<span class="comment">//设置四个学生信息 </span></span><br><span class="line">	a[<span class="number">0</span>].name=<span class="string">&quot;dingbudele&quot;</span>,a[<span class="number">0</span>].xuehao=<span class="string">&quot;114515&quot;</span>,a[<span class="number">0</span>].score=<span class="number">750</span>;</span><br><span class="line">	a[<span class="number">1</span>].name=<span class="string">&quot;ewoji&quot;</span>,a[<span class="number">1</span>].xuehao=<span class="string">&quot;114514&quot;</span>,a[<span class="number">1</span>].score=<span class="number">750</span>;</span><br><span class="line">	a[<span class="number">2</span>].name=<span class="string">&quot;niganma&quot;</span>,a[<span class="number">2</span>].xuehao=<span class="string">&quot;114511&quot;</span>,a[<span class="number">2</span>].score=<span class="number">666</span>;</span><br><span class="line">	a[<span class="number">3</span>].name=<span class="string">&quot;zhendeshinia&quot;</span>,a[<span class="number">3</span>].xuehao=<span class="string">&quot;114512&quot;</span>,a[<span class="number">3</span>].score=<span class="number">99</span>;</span><br><span class="line">	<span class="built_in">sort</span>(a,a+<span class="number">4</span>,cmp);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">		cout&lt;&lt;a[i].name&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;a[i].xuehao&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;a[i].score&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<p><img src="%E7%BB%93%E6%9E%84%E4%BD%93%E6%8E%92%E5%BA%8F%E8%BE%93%E5%87%BA.png" alt="结构体排序输出"></p>
<p>可以看到成绩高的在前面，并且成绩相同时学号小的在前面喵，恭喜学号为114514的同学夺得第一，OVO。</p>
]]></content>
      <tags>
        <tag>入门</tag>
        <tag>算法</tag>
      </tags>
  </entry>
</search>
